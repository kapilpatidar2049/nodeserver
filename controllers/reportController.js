import multer from 'multer';
import fs from 'fs';
import Tesseract from 'tesseract.js';
import { GoogleGenerativeAI } from '@google/generative-ai';

// Multer config for multiple image uploads
const upload = multer({ dest: 'uploads/' });
export const uploadReport = upload.array('files', 5);

// Gemini init
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });

export const analyzeReport = async (req, res) => {
  try {
    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ success: false, message: "No files uploaded." });
    }

    let allText = '';

    for (const file of req.files) {
      if (!file.mimetype.startsWith('image/')) {
        continue;
      }

      const { data: { text } } = await Tesseract.recognize(file.path, 'eng');
      const cleanText = text.trim().replace(/\s{2,}/g, ' ');
      // console.log(`Extracted text from ${file.originalname}:`, cleanText.slice(0, 200));
      allText += cleanText + '\n\n';
    }

    if (!allText) {
      return res.status(400).json({ success: false, message: "Could not extract any text from the images." });
    }

    const tableData = [];
    allText.split('\n').forEach(line => {
      if (line.includes(':')) {
        const [testName, rest] = line.split(':');
        tableData.push({
          testName: testName.trim(),
          result: rest.trim(),
          range: ''
        });
      } else if (line.includes('\t')) {
        const parts = line.split('\t');
        if (parts.length >= 2) {
          tableData.push({
            testName: parts[0].trim(),
            result: parts[1].trim(),
            range: parts[2]?.trim() || ''
          });
        }
      }
    });

    //  AI prompt to Gemini
const prompt = `
You are a medical lab parsing and explanation assistant. You will receive two inputs: PARSED_ROWS (may contain OCR noise) and FULL_OCR (the full text).

STRICT OUTPUT: Return exactly TWO sections in plain text. Do NOT use JSON, code blocks, Markdown, or backticks.

PART A: CLEANED TEST RESULTS
- Output ONE test per line using this exact format:
Test = <name>; Result = <value>; Range = <range or "not provided">
- No bullets beyond the leading "Test =". No extra commentary in Part A.

CLEANING RULES (apply before listing any line in Part A):
1) Keep a row only if:
   - test name is 2-60 chars, mostly letters/spaces with allowed tokens (%, /, -, +, ., digits).
   - result is a valid numeric (optionally with unit, e.g., "13.5 g/dL", "120 mg/dL", "5.8 %"),
     OR a clear qualitative label ("Normal", "High", "Low", "Positive", "Negative", "Reactive", "Non-reactive", "Pending").
   - range, if present, looks like "x-y unit", "x - y unit", "Ref Range: x-y", ">= x", or "up to y".
2) If range not found, write Range = "not provided".
3) Deduplicate by case-insensitive test name; prefer a numeric result over a qualitative one if both exist.
4) Normalize test names to Title Case except common abbreviations (HbA1c, TSH, T3, T4, HDL, LDL, VLDL, RBC, WBC, PLT, CRP, ESR, ALT, AST, ALP, GGT, eGFR, BUN, SGOT, SGPT).
5) DROP rows that look like OCR gibberish (random characters or malformed tokens).

PART B: PATIENT SUMMARY
- Plain English, no diagnosis. Group related tests (e.g., Blood counts, Lipid profile, Liver, Kidney, Thyroid, Diabetes).
- For each kept test, briefly state what it measures and whether it's within/above/below the provided range (if a range exists). Do NOT invent missing ranges.
- Provide concise general guidance (diet, exercise, sleep, hydration, stress, medicines) and when to consult a doctor.
- End EXACTLY with:
This summary was generated by AI. Always consult a licensed doctor for final interpretation.

PARSED_ROWS (may contain noise):
${JSON.stringify(tableData, null, 2)}

FULL_OCR (context only; do not invent data not present here):
${allText}
`.trim();



    const result = await model.generateContent(prompt);
    const aiResponse = result.response.text();

    res.json({
      success: true,
      extractedText: allText.trim(),
      extractedTests: tableData,
      aiSummary: aiResponse
    });

  } catch (err) {
    console.error('Analyze report error:', err);
    res.status(500).json({ success: false, message: "Failed to analyze report.", error: err.message });
  } finally {
    // clean up uploaded files
    if (req.files) {
      req.files.forEach(file => {
        if (fs.existsSync(file.path)) fs.unlinkSync(file.path);
      });
    }
  }
};
